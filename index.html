<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>
  <script>
    class SmokeShaderAddon {
      constructor() {
        this.canvas = document.getElementById('smokeCanvas');
        this.gl = null;
        this.program = null;
        this.startTime = performance.now();
        this.isFirstRender = true;
        this.animationId = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          color1: config.color1 ?? '#FF6B35',
          color2: config.color2 ?? '#FF0000',
          speed: config.speed ?? 0.68,
          origin: config.origin ?? 0,
          direction: config.direction ?? 0,
          scale: config.scale ?? 7.0,
          brightness: config.brightness ?? 0.9,
          opacity: config.opacity ?? 1.0,
          detail: config.detail ?? 0.75,
          turbulence: config.turbulence ?? 1.7,
          fade: config.fade ?? 1.05,
          height: config.height ?? 0.8
        };

        this.handleResize = this.resize.bind(this);

        this.init();
      }

      init() {
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          requestAnimationFrame(() => this.init());
          return;
        }

        this.setupWebGL();
        this.createShaderProgram();
        this.setupEventListeners();
        this.render();
      }

      setupWebGL() {
        this.gl = this.canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: true
        });

        if (!this.gl) {
          console.error('WebGL2 not supported');
          return;
        }

        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        this.resize();
      }

      resize() {
        const dpr = window.devicePixelRatio || 1;
        const width = this.canvas.clientWidth * dpr;
        const height = this.canvas.clientHeight * dpr;

        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          if (this.gl) {
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          }
        }
      }

      setupEventListeners() {
        window.addEventListener('resize', this.handleResize);

        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          api.onSettingsChange((newSettings) => {
            Object.assign(this.settings, newSettings);
          });

          api.onButtonClick('randomizeColorsBtn', () => {
            this.randomizeColors();
          });

          api.onEvent('viewport:resize', () => this.resize());
          api.onPause(() => this.stop());
          api.onResume(() => this.start());
          api.onUnmount(() => this.dispose());

          api.ready({
            capabilities: ['hot-reload'],
            subscribedEvents: ['viewport:resize']
          });
        }
      }

      randomizeColors() {
        const baseHue = Math.random() * 360;
        const colors = {
          color1: this.hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: this.hslToHex((baseHue + 30 + Math.random() * 60) % 360, 60 + Math.random() * 40, 35 + Math.random() * 25)
        };

        if (window.MyWallpaper?.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }
        Object.assign(this.settings, colors);
      }

      hslToHex(h, s, l) {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      createShaderProgram() {
        const gl = this.gl;

        const vertexShaderSource = `#version 300 es
          precision mediump float;
          const vec2 positions[6] = vec2[6](
            vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
            vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
          );
          out vec2 uv;
          void main() {
            uv = positions[gl_VertexID];
            gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform float time;
          uniform vec2 resolution;
          uniform vec3 color1;
          uniform vec3 color2;
          uniform float speed;
          uniform float origin;
          uniform float direction;
          uniform float scale;
          uniform float brightness;
          uniform float opacity;
          uniform float detail;
          uniform float turbulence;
          uniform float fade;
          uniform float height;

          in vec2 uv;
          out vec4 fragColor;

          float hash(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
          }

          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f * f * (3.0 - 2.0 * f);

            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));

            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          float fbm(vec2 p, int octaves) {
            float value = 0.0;
            float amplitude = 0.4;
            vec2 freq = p;

            for (int i = 0; i < 14; i++) {
              if (i >= octaves) break;
              value += amplitude * noise(freq);
              freq *= 2.0;
              amplitude *= 0.4;
            }
            return value;
          }

          void main() {
            vec2 pos = uv;

            float aspectRatio = resolution.x / resolution.y;
            pos.x *= aspectRatio;

            // Origin: where smoke comes from (controls gradient/fade)
            float originRad = radians(origin);
            vec2 originDir = vec2(sin(originRad), cos(originRad));
            float gradientBasis = dot(pos, originDir);

            // Direction: where smoke travels toward (controls scroll)
            float dirRad = radians(direction);
            vec2 moveDir = vec2(sin(dirRad), cos(dirRad));

            // Smoke coordinates with inverted scale (scale=1 -> freq 7, matching original)
            vec2 smokeCoords = (pos - moveDir * time * speed) * (7.0 / scale);

            // Octaves from detail parameter (detail=0.75 -> 5 octaves, matching original)
            int octaves = 2 + int(detail * 4.0);

            // Gradient with noise modulation
            float gradient = mix(gradientBasis * 0.3, gradientBasis * 0.7, fbm(smokeCoords, octaves));

            // Base smoke shape
            float noise1 = fbm(smokeCoords, octaves);

            // Turbulent movement (subtle scalar drift for organic feel, doesn't overpower speed)
            float noise2 = turbulence * fbm(smokeCoords + noise1 + time * 0.2, octaves) - 0.5;

            // Smoke intensity: cross-feed for organic movement
            float smokeIntensity = fbm(vec2(noise2, noise1), octaves);

            // Color brightness
            vec3 smokeColor = mix(color2, color1, smokeIntensity) * brightness;

            // Alpha: fade controls gradient sharpness, height controls extension
            float smokeAlpha = smoothstep(0.0, fade, (smokeIntensity - gradient + 0.3) * height);

            fragColor = vec4(smokeColor, smokeAlpha * opacity);
          }
        `;

        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) return;

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(this.program));
          return;
        }

        // Cleanup shaders after successful linkage
        gl.detachShader(this.program, vertexShader);
        gl.deleteShader(vertexShader);
        gl.detachShader(this.program, fragmentShader);
        gl.deleteShader(fragmentShader);

        gl.useProgram(this.program);

        this.uniforms = {
          time: gl.getUniformLocation(this.program, 'time'),
          resolution: gl.getUniformLocation(this.program, 'resolution'),
          color1: gl.getUniformLocation(this.program, 'color1'),
          color2: gl.getUniformLocation(this.program, 'color2'),
          speed: gl.getUniformLocation(this.program, 'speed'),
          origin: gl.getUniformLocation(this.program, 'origin'),
          direction: gl.getUniformLocation(this.program, 'direction'),
          scale: gl.getUniformLocation(this.program, 'scale'),
          brightness: gl.getUniformLocation(this.program, 'brightness'),
          opacity: gl.getUniformLocation(this.program, 'opacity'),
          detail: gl.getUniformLocation(this.program, 'detail'),
          turbulence: gl.getUniformLocation(this.program, 'turbulence'),
          fade: gl.getUniformLocation(this.program, 'fade'),
          height: gl.getUniformLocation(this.program, 'height')
        };
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [1, 1, 1];
      }

      render = () => {
        if (!this.gl || !this.program) {
          this.animationId = requestAnimationFrame(this.render);
          return;
        }

        const gl = this.gl;
        const currentTime = (performance.now() - this.startTime) / 1000;

        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(this.uniforms.time, currentTime);
        gl.uniform2fv(this.uniforms.resolution, [this.canvas.width, this.canvas.height]);

        gl.uniform3fv(this.uniforms.color1, this.hexToRgb(this.settings.color1));
        gl.uniform3fv(this.uniforms.color2, this.hexToRgb(this.settings.color2));

        gl.uniform1f(this.uniforms.speed, this.settings.speed);
        gl.uniform1f(this.uniforms.origin, this.settings.origin);
        gl.uniform1f(this.uniforms.direction, this.settings.direction);
        gl.uniform1f(this.uniforms.scale, this.settings.scale);
        gl.uniform1f(this.uniforms.brightness, this.settings.brightness);
        gl.uniform1f(this.uniforms.opacity, this.settings.opacity);
        gl.uniform1f(this.uniforms.detail, this.settings.detail);
        gl.uniform1f(this.uniforms.turbulence, this.settings.turbulence);
        gl.uniform1f(this.uniforms.fade, this.settings.fade);
        gl.uniform1f(this.uniforms.height, this.settings.height);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        this.animationId = requestAnimationFrame(this.render);
      }

      start() {
        if (!this.animationId) {
          this.render();
        }
      }

      stop() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      dispose() {
        this.stop();
        if (this.gl && this.program) {
          this.gl.deleteProgram(this.program);
          this.program = null;
        }
        this.gl = null;
        this.canvas = null;
        window.removeEventListener('resize', this.handleResize);
      }
    }

    if (document.readyState === 'complete') {
      window.smokeShader = new SmokeShaderAddon();
    } else {
      window.addEventListener('load', () => {
        window.smokeShader = new SmokeShaderAddon();
      });
    }
  </script>
</body>
</html>
