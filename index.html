<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>
  <script>
    class SmokeShaderAddon {
      constructor() {
        this.canvas = document.getElementById('smokeCanvas');
        this.gl = null;
        this.program = null;
        this.startTime = Date.now();
        this.isFirstRender = true;
        this.animationId = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          color1: config.color1 ?? '#6e0061',
          color2: config.color2 ?? '#ad00a1',
          color3: config.color3 ?? '#a401d6',
          color4: config.color4 ?? '#4a0080',
          speed: config.speed ?? 0.2,
          turbulence: config.turbulence ?? 0.9,
          density: config.density ?? 7.0,
          intensity: config.intensity ?? 0.9,
          smokeEdge: config.smokeEdge ?? 'bottom',
          smokeHeight: config.smokeHeight ?? 0.6
        };

        this.init();
      }

      init() {
        this.setupWebGL();
        this.createShaderProgram();
        this.setupEventListeners();
        this.render();
      }

      setupWebGL() {
        this.gl = this.canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: true
        });

        if (!this.gl) {
          this.gl = this.canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false,
            antialias: true
          });
        }

        if (!this.gl) {
          console.error('WebGL not supported');
          return;
        }

        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        this.resize();
      }

      resize() {
        const dpr = window.devicePixelRatio || 1;
        const width = this.canvas.clientWidth * dpr;
        const height = this.canvas.clientHeight * dpr;

        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          if (this.gl) {
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          }
        }
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.resize());

        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          api.onSettingsChange((newSettings) => {
            Object.assign(this.settings, newSettings);
          });

          api.onButtonClick('randomizeColorsBtn', () => {
            this.randomizeColors();
          });

          api.onEvent('viewport:resize', () => this.resize());
          api.onPause(() => this.stop());
          api.onResume(() => this.start());

          api.ready({ supportsHotReload: true });
        }
      }

      randomizeColors() {
        const baseHue = Math.random() * 360;
        const colors = {
          color1: this.hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: this.hslToHex((baseHue + 30 + Math.random() * 30) % 360, 70 + Math.random() * 30, 30 + Math.random() * 20),
          color3: this.hslToHex((baseHue + 60 + Math.random() * 60) % 360, 60 + Math.random() * 40, 40 + Math.random() * 20),
          color4: this.hslToHex((baseHue + 180 + Math.random() * 60 - 30) % 360, 50 + Math.random() * 50, 25 + Math.random() * 15)
        };

        if (window.MyWallpaper?.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }
        Object.assign(this.settings, colors);
      }

      hslToHex(h, s, l) {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      createShaderProgram() {
        const gl = this.gl;

        const vertexShaderSource = `#version 300 es
          precision mediump float;
          const vec2 positions[6] = vec2[6](
            vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
            vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
          );
          out vec2 uv;
          void main() {
            uv = positions[gl_VertexID];
            gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform float time;
          uniform vec2 resolution;
          uniform vec3 color1;
          uniform vec3 color2;
          uniform vec3 color3;
          uniform vec3 color4;
          uniform float intensity;
          uniform float speed;
          uniform float scale;
          uniform float turbulence;
          uniform int smokeEdge;
          uniform float smokeHeight;

          in vec2 uv;
          out vec4 fragColor;

          float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
          }

          float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          #define OCTAVES 5
          float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.4;
            vec2 freq = st;
            for (int i = 0; i < OCTAVES; i++) {
              value += amplitude * noise(freq);
              freq *= 2.0;
              amplitude *= 0.4;
            }
            return value;
          }

          void main() {
            vec2 st = uv;
            float aspectRatio = resolution.x / resolution.y;
            st.x *= aspectRatio;

            // Coordonnées pour le bruit
            vec2 smokeCoords = st * scale;

            // Première couche de bruit
            float noise1 = fbm(smokeCoords);

            // Seconde couche avec animation (speed fonctionne ici)
            float noise2 = turbulence * fbm(smokeCoords + noise1 + time * speed * 5.0) - 0.5;

            // Combinaison des bruits
            float finalNoise = turbulence * fbm(vec2(noise1, noise2));
            float smokeIntensity = fbm(vec2(noise2, noise1));

            // Mélange des 4 couleurs
            vec3 baseColor = mix(color1, color2, smokeIntensity);
            vec3 accentColor = mix(color3, color4, finalNoise);
            vec3 finalColor = mix(baseColor, accentColor, noise1 * 0.5 + 0.25);
            finalColor *= intensity;

            // Alpha de base depuis le bruit
            float smokeAlpha = smokeIntensity;

            // Position normalisée (0 à 1)
            float y = (uv.y + 1.0) * 0.5;  // 0 = bas, 1 = haut
            float x = (uv.x + 1.0) * 0.5;  // 0 = gauche, 1 = droite

            // Appliquer le masque selon l'origine de la fumée
            float reach = smokeHeight;

            if (smokeEdge == 0) {
              // all - fumée partout
              // pas de masque
            } else if (smokeEdge == 1) {
              // bottom - fumée part du bas
              smokeAlpha *= smoothstep(0.0, reach, y);
            } else if (smokeEdge == 2) {
              // top - fumée part du haut
              smokeAlpha *= smoothstep(1.0, 1.0 - reach, y);
            } else if (smokeEdge == 3) {
              // left - fumée part de la gauche
              smokeAlpha *= smoothstep(0.0, reach, x);
            } else if (smokeEdge == 4) {
              // right - fumée part de la droite
              smokeAlpha *= smoothstep(1.0, 1.0 - reach, x);
            } else if (smokeEdge == 5) {
              // center - fumée part du centre
              float dist = length(uv);
              smokeAlpha *= 1.0 - smoothstep(0.0, reach * 1.5, dist);
            }

            fragColor = vec4(finalColor, smokeAlpha);
          }
        `;

        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) return;

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(this.program));
          return;
        }

        gl.useProgram(this.program);

        this.uniforms = {
          time: gl.getUniformLocation(this.program, 'time'),
          resolution: gl.getUniformLocation(this.program, 'resolution'),
          color1: gl.getUniformLocation(this.program, 'color1'),
          color2: gl.getUniformLocation(this.program, 'color2'),
          color3: gl.getUniformLocation(this.program, 'color3'),
          color4: gl.getUniformLocation(this.program, 'color4'),
          intensity: gl.getUniformLocation(this.program, 'intensity'),
          speed: gl.getUniformLocation(this.program, 'speed'),
          scale: gl.getUniformLocation(this.program, 'scale'),
          turbulence: gl.getUniformLocation(this.program, 'turbulence'),
          smokeEdge: gl.getUniformLocation(this.program, 'smokeEdge'),
          smokeHeight: gl.getUniformLocation(this.program, 'smokeHeight')
        };
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [1, 1, 1];
      }

      smokeEdgeToInt(value) {
        const map = { all: 0, bottom: 1, top: 2, left: 3, right: 4, center: 5 };
        return value in map ? map[value] : 1;
      }

      render = () => {
        if (!this.gl || !this.program) {
          this.animationId = requestAnimationFrame(this.render);
          return;
        }

        const gl = this.gl;
        const currentTime = (Date.now() - this.startTime) / 1000;

        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(this.uniforms.time, currentTime);
        gl.uniform2fv(this.uniforms.resolution, [this.canvas.width, this.canvas.height]);

        gl.uniform3fv(this.uniforms.color1, this.hexToRgb(this.settings.color1));
        gl.uniform3fv(this.uniforms.color2, this.hexToRgb(this.settings.color2));
        gl.uniform3fv(this.uniforms.color3, this.hexToRgb(this.settings.color3));
        gl.uniform3fv(this.uniforms.color4, this.hexToRgb(this.settings.color4));

        gl.uniform1f(this.uniforms.intensity, this.settings.intensity);
        gl.uniform1f(this.uniforms.speed, this.settings.speed);
        gl.uniform1f(this.uniforms.scale, this.settings.density);
        gl.uniform1f(this.uniforms.turbulence, this.settings.turbulence);
        gl.uniform1i(this.uniforms.smokeEdge, this.smokeEdgeToInt(this.settings.smokeEdge));
        gl.uniform1f(this.uniforms.smokeHeight, this.settings.smokeHeight);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        this.animationId = requestAnimationFrame(this.render);
      }

      start() {
        if (!this.animationId) {
          this.render();
        }
      }

      stop() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      window.smokeShader = new SmokeShaderAddon();
    });
  </script>
</body>
</html>
