<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>
  <script>
    class SmokeShaderAddon {
      constructor() {
        this.canvas = document.getElementById('smokeCanvas');
        this.gl = null;
        this.program = null;
        this.startTime = performance.now();
        this.isFirstRender = true;
        this.animationId = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          color: config.color ?? '#FFFFFF',
          speed: config.speed ?? 0.28,
          origin: config.origin ?? 0,
          direction: config.direction ?? 0,
          scale: config.scale ?? 6.0,
          brightness: config.brightness ?? 1.0,
          opacity: config.opacity ?? 1.0,
          detail: config.detail ?? 1.25,
          turbulence: config.turbulence ?? 2.0,
          density: config.density ?? 0.5,
          height: config.height ?? 0.7,
          quality: config.quality ?? 1.0
        };

        // Pre-allocated typed arrays (avoid per-frame GC)
        this.colorRGB = new Float32Array(3);
        this.resolutionArray = new Float32Array(2);
        this.settingsDirty = true;

        this.cacheColors();
        this.handleResize = this.resize.bind(this);

        this.init();
      }

      init() {
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          requestAnimationFrame(() => this.init());
          return;
        }

        this.setupWebGL();
        this.createShaderProgram();
        this.setupEventListeners();
        this.render();
      }

      setupWebGL() {
        this.gl = this.canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: false
        });

        if (!this.gl) {
          console.error('WebGL2 not supported');
          return;
        }

        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        this.generateNoiseTexture();
        this.resize();
      }

      resize() {
        const quality = this.settings.quality ?? 1.0;
        const dpr = (window.devicePixelRatio || 1) * quality;
        const width = this.canvas.clientWidth * dpr;
        const height = this.canvas.clientHeight * dpr;

        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          this.resolutionArray[0] = width;
          this.resolutionArray[1] = height;
          if (this.gl) {
            this.gl.viewport(0, 0, width, height);
          }
        }
      }

      generateNoiseTexture() {
        const gl = this.gl;
        const size = 256;
        const cells = 16;
        const data = new Uint8Array(size * size);

        // Random unit gradients on tileable grid
        const gradients = new Float32Array(cells * cells * 2);
        for (let i = 0; i < cells * cells; i++) {
          const angle = Math.random() * Math.PI * 2;
          gradients[i * 2] = Math.cos(angle);
          gradients[i * 2 + 1] = Math.sin(angle);
        }

        const fade = t => t * t * t * (t * (t * 6 - 15) + 10);

        const dotGrad = (gx, gy, dx, dy) => {
          const idx = (((gy % cells + cells) % cells) * cells + ((gx % cells + cells) % cells)) * 2;
          return gradients[idx] * dx + gradients[idx + 1] * dy;
        };

        for (let py = 0; py < size; py++) {
          for (let px = 0; px < size; px++) {
            const x = (px / size) * cells;
            const y = (py / size) * cells;
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const dx = x - x0;
            const dy = y - y0;
            const u = fade(dx);
            const v = fade(dy);

            const n00 = dotGrad(x0, y0, dx, dy);
            const n10 = dotGrad(x0 + 1, y0, dx - 1, dy);
            const n01 = dotGrad(x0, y0 + 1, dx, dy - 1);
            const n11 = dotGrad(x0 + 1, y0 + 1, dx - 1, dy - 1);

            const nx0 = n00 + u * (n10 - n00);
            const nx1 = n01 + u * (n11 - n01);
            const value = nx0 + v * (nx1 - nx0);

            data[py * size + px] = Math.max(0, Math.min(255, ((value / 1.414 + 0.5) * 255) | 0));
          }
        }

        this.noiseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, size, size, 0, gl.RED, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      }

      setupEventListeners() {
        window.addEventListener('resize', this.handleResize);

        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          api.onSettingsChange((newSettings) => {
            const qualityChanged = newSettings.quality !== undefined && newSettings.quality !== this.settings.quality;
            Object.assign(this.settings, newSettings);
            this.cacheColors();
            this.settingsDirty = true;
            if (qualityChanged) this.resize();
          });

          api.onButtonClick('randomizeColorBtn', () => {
            this.randomizeColor();
          });

          api.onEvent('viewport:resize', () => this.resize());
          api.onPause(() => this.stop());
          api.onResume(() => this.start());
          api.onUnmount(() => this.dispose());

          api.ready({
            capabilities: ['hot-reload'],
            subscribedEvents: ['viewport:resize']
          });
        }
      }

      randomizeColor() {
        const hue = Math.random() * 360;
        const s = 70 + Math.random() * 30;
        const l = 40 + Math.random() * 30;
        const color = this.hslToHex(hue, s, l);

        if (window.MyWallpaper?.settings) {
          window.MyWallpaper.settings.setValues({ color });
        }
        this.settings.color = color;
        this.cacheColors();
        this.settingsDirty = true;
      }

      hslToHex(h, s, l) {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      createShaderProgram() {
        const gl = this.gl;

        const vertexShaderSource = `#version 300 es
          precision mediump float;
          const vec2 positions[6] = vec2[6](
            vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
            vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
          );
          out vec2 uv;
          void main() {
            uv = positions[gl_VertexID];
            gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform float time;
          uniform vec2 resolution;
          uniform vec3 color;
          uniform float speed;
          uniform float origin;
          uniform float direction;
          uniform float scale;
          uniform float brightness;
          uniform float opacity;
          uniform float detail;
          uniform float turbulence;
          uniform float density;
          uniform float height;
          uniform sampler2D noiseTex;

          in vec2 uv;
          out vec4 fragColor;

          // Integer hash — screen-space dithering only
          float hash(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
          }

          // Perlin noise via texture lookup [0, 1]
          float noise(vec2 p) {
            return texture(noiseTex, p / 16.0).r;
          }

          float fbm(vec2 p, int octaves) {
            float value = 0.0;
            float amplitude = 0.4;
            vec2 freq = p;
            mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);

            for (int i = 0; i < 8; i++) {
              if (i >= octaves) break;
              value += amplitude * noise(freq);
              freq = rot * freq * 2.0;
              amplitude *= 0.4;
            }
            return value;
          }

          void main() {
            vec2 pos = uv;

            float aspectRatio = resolution.x / resolution.y;
            pos.x *= aspectRatio;

            // Origin: where smoke comes from (controls gradient)
            float originRad = radians(origin);
            vec2 originDir = vec2(sin(originRad), cos(originRad));
            float gradientBasis = dot(pos, originDir);

            // Early-out: no smoke possible far from origin
            if (gradientBasis > 3.0) {
              fragColor = vec4(0.0);
              return;
            }

            // Direction: where smoke travels toward (controls scroll)
            float dirRad = radians(direction);
            vec2 moveDir = vec2(sin(dirRad), cos(dirRad));

            // Speed controls all animation (scroll + turbulence)
            float t = time * speed;

            // Smoke coordinates with inverted scale (scale=1 -> freq 7, matching original)
            vec2 smokeCoords = (pos - moveDir * t) * (7.0 / scale);

            // Octaves from detail parameter (range 2-8)
            int octaves = 2 + int(detail * 2.0);

            // Base noise (reused for gradient and warp — avoids redundant fbm call)
            float baseNoise = fbm(smokeCoords, octaves);

            // Gradient with noise modulation
            float gradient = mix(gradientBasis * 0.3, gradientBasis * 0.7, baseNoise);

            // Early-out: gradient too high for any smoke
            if (gradient > 1.0) {
              fragColor = vec4(0.0);
              return;
            }

            // Independent Y warp (single noise — offset breaks correlation with baseNoise)
            float warpY = noise(smokeCoords * 1.7 + vec2(5.2, 1.3));

            // Turbulent movement with 2D warp (reduced octaves — warped input needs less detail)
            float noise2 = turbulence * fbm(smokeCoords + vec2(baseNoise, warpY) + t * 0.7, min(octaves, 5)) - 0.5;

            // Smoke intensity: cross-feed for organic movement (half octaves — already-distorted input)
            float smokeIntensity = fbm(vec2(noise2, baseNoise), max(octaves / 2, 2));

            // Color brightness
            vec3 smokeColor = color * brightness;

            // Alpha: height controls how far smoke extends
            float smokeAlpha = smoothstep(0.0, 0.8, (smokeIntensity - gradient + 0.3) * height);

            // Density: reshape alpha curve (low = wispy, high = thick)
            smokeAlpha = pow(smokeAlpha, 1.0 / max(density, 0.01));

            // Dithering: break Mach bands with screen-space noise (±0.5/255)
            float dither = (hash(gl_FragCoord.xy + fract(time)) - 0.5) / 255.0;
            smokeColor += dither;
            smokeAlpha += dither;

            fragColor = vec4(smokeColor, smokeAlpha * opacity);
          }
        `;

        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) return;

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(this.program));
          return;
        }

        // Cleanup shaders after successful linkage
        gl.detachShader(this.program, vertexShader);
        gl.deleteShader(vertexShader);
        gl.detachShader(this.program, fragmentShader);
        gl.deleteShader(fragmentShader);

        gl.useProgram(this.program);

        this.uniforms = {
          time: gl.getUniformLocation(this.program, 'time'),
          resolution: gl.getUniformLocation(this.program, 'resolution'),
          color: gl.getUniformLocation(this.program, 'color'),
          speed: gl.getUniformLocation(this.program, 'speed'),
          origin: gl.getUniformLocation(this.program, 'origin'),
          direction: gl.getUniformLocation(this.program, 'direction'),
          scale: gl.getUniformLocation(this.program, 'scale'),
          brightness: gl.getUniformLocation(this.program, 'brightness'),
          opacity: gl.getUniformLocation(this.program, 'opacity'),
          detail: gl.getUniformLocation(this.program, 'detail'),
          turbulence: gl.getUniformLocation(this.program, 'turbulence'),
          density: gl.getUniformLocation(this.program, 'density'),
          height: gl.getUniformLocation(this.program, 'height')
        };

        // Bind noise texture to unit 0 (stays bound permanently)
        gl.uniform1i(gl.getUniformLocation(this.program, 'noiseTex'), 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      hexToRgb(hex, out) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        if (result) {
          out[0] = parseInt(result[1], 16) / 255;
          out[1] = parseInt(result[2], 16) / 255;
          out[2] = parseInt(result[3], 16) / 255;
        } else {
          out[0] = out[1] = out[2] = 1;
        }
      }

      cacheColors() {
        this.hexToRgb(this.settings.color, this.colorRGB);
      }

      render = () => {
        if (!this.gl || !this.program) {
          this.animationId = requestAnimationFrame(this.render);
          return;
        }

        const gl = this.gl;

        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(this.uniforms.time, (performance.now() - this.startTime) / 1000);
        gl.uniform2fv(this.uniforms.resolution, this.resolutionArray);

        if (this.settingsDirty) {
          this.settingsDirty = false;
          gl.uniform3fv(this.uniforms.color, this.colorRGB);
          gl.uniform1f(this.uniforms.speed, this.settings.speed);
          gl.uniform1f(this.uniforms.origin, this.settings.origin);
          gl.uniform1f(this.uniforms.direction, this.settings.direction);
          gl.uniform1f(this.uniforms.scale, this.settings.scale);
          gl.uniform1f(this.uniforms.brightness, this.settings.brightness);
          gl.uniform1f(this.uniforms.opacity, this.settings.opacity);
          gl.uniform1f(this.uniforms.detail, this.settings.detail);
          gl.uniform1f(this.uniforms.turbulence, this.settings.turbulence);
          gl.uniform1f(this.uniforms.density, this.settings.density);
          gl.uniform1f(this.uniforms.height, this.settings.height);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        this.animationId = requestAnimationFrame(this.render);
      }

      start() {
        if (!this.animationId) {
          this.render();
        }
      }

      stop() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      dispose() {
        this.stop();
        if (this.gl) {
          if (this.noiseTexture) {
            this.gl.deleteTexture(this.noiseTexture);
            this.noiseTexture = null;
          }
          if (this.program) {
            this.gl.deleteProgram(this.program);
            this.program = null;
          }
        }
        this.gl = null;
        this.canvas = null;
        window.removeEventListener('resize', this.handleResize);
      }
    }

    if (document.readyState === 'complete') {
      window.smokeShader = new SmokeShaderAddon();
    } else {
      window.addEventListener('load', () => {
        window.smokeShader = new SmokeShaderAddon();
      });
    }
  </script>
</body>
</html>
