<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>
  <script>
    class SmokeShaderAddon {
      constructor() {
        this.canvas = document.getElementById('smokeCanvas');
        this.gl = null;
        this.program = null;
        this.startTime = performance.now();
        this.isFirstRender = true;
        this.animationId = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          color1: config.color1 ?? '#FF6B35',
          color2: config.color2 ?? '#FF0000',
          speed: config.speed ?? 0.34,
          origin: config.origin ?? 0,
          direction: config.direction ?? 0,
          scale: config.scale ?? 7.0,
          brightness: config.brightness ?? 0.9,
          opacity: config.opacity ?? 1.0,
          detail: config.detail ?? 3.0,
          turbulence: config.turbulence ?? 2.0,
          fade: config.fade ?? 1.2,
          height: config.height ?? 0.8,
          quality: config.quality ?? 1.0
        };

        // Pre-allocated typed arrays (avoid per-frame GC)
        this.color1RGB = new Float32Array(3);
        this.color2RGB = new Float32Array(3);
        this.resolutionArray = new Float32Array(2);
        this.settingsDirty = true;

        this.cacheColors();
        this.handleResize = this.resize.bind(this);

        this.init();
      }

      init() {
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          requestAnimationFrame(() => this.init());
          return;
        }

        this.setupWebGL();
        this.createShaderProgram();
        this.setupEventListeners();
        this.render();
      }

      setupWebGL() {
        this.gl = this.canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: false
        });

        if (!this.gl) {
          console.error('WebGL2 not supported');
          return;
        }

        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        this.generateNoiseTexture();
        this.generateFbmTexture();
        this.resize();
      }

      generateNoiseTexture() {
        const gl = this.gl;
        const size = 256;
        const data = new Uint8Array(size * size);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 256;
        }
        this.noiseData = data;
        this.noiseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, size, size, 0, gl.RED, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      }

      generateFbmTexture() {
        const gl = this.gl;
        const size = 256;
        const noiseData = this.noiseData;

        // Bilinear sample matching GPU texture lookup (REPEAT + LINEAR)
        function sampleNoise(x, y) {
          x = ((x % size) + size) % size;
          y = ((y % size) + size) % size;
          const ix = Math.floor(x);
          const iy = Math.floor(y);
          const fx = x - ix;
          const fy = y - iy;
          const ix1 = (ix + 1) % size;
          const iy1 = (iy + 1) % size;
          const a = noiseData[iy * size + ix] / 255;
          const b = noiseData[iy * size + ix1] / 255;
          const c = noiseData[iy1 * size + ix] / 255;
          const d = noiseData[iy1 * size + ix1] / 255;
          return a * (1 - fx) * (1 - fy) + b * fx * (1 - fy) + c * (1 - fx) * fy + d * fx * fy;
        }

        // Bake FBM at 4 octave levels into RGBA (2, 4, 6, 8 octaves)
        // FBM_PERIOD = 8 world units per texture tile
        const FBM_PERIOD = 8.0;
        const data = new Uint8Array(size * size * 4);

        for (let j = 0; j < size; j++) {
          for (let i = 0; i < size; i++) {
            const px = i * FBM_PERIOD / size;
            const py = j * FBM_PERIOD / size;

            let value = 0, amplitude = 0.4;
            let fx = px, fy = py;
            let v2 = 0, v4 = 0, v6 = 0;

            for (let oct = 0; oct < 8; oct++) {
              value += amplitude * sampleNoise(fx, fy);
              if (oct === 1) v2 = value;
              if (oct === 3) v4 = value;
              if (oct === 5) v6 = value;
              // Rotation mat2(0.8, 0.6, -0.6, 0.8) then *2
              const nfx = (0.8 * fx + 0.6 * fy) * 2.0;
              const nfy = (-0.6 * fx + 0.8 * fy) * 2.0;
              fx = nfx;
              fy = nfy;
              amplitude *= 0.4;
            }

            const idx = (j * size + i) * 4;
            data[idx]     = Math.round(Math.min(1, Math.max(0, v2)) * 255);
            data[idx + 1] = Math.round(Math.min(1, Math.max(0, v4)) * 255);
            data[idx + 2] = Math.round(Math.min(1, Math.max(0, v6)) * 255);
            data[idx + 3] = Math.round(Math.min(1, Math.max(0, value)) * 255);
          }
        }

        this.fbmTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.fbmTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      }

      resize() {
        const quality = this.settings.quality ?? 1.0;
        const dpr = (window.devicePixelRatio || 1) * quality;
        const width = this.canvas.clientWidth * dpr;
        const height = this.canvas.clientHeight * dpr;

        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          this.resolutionArray[0] = width;
          this.resolutionArray[1] = height;
          if (this.gl) {
            this.gl.viewport(0, 0, width, height);
          }
        }
      }

      setupEventListeners() {
        window.addEventListener('resize', this.handleResize);

        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          api.onSettingsChange((newSettings) => {
            const qualityChanged = newSettings.quality !== undefined && newSettings.quality !== this.settings.quality;
            Object.assign(this.settings, newSettings);
            this.cacheColors();
            this.settingsDirty = true;
            if (qualityChanged) this.resize();
          });

          api.onButtonClick('randomizeColorsBtn', () => {
            this.randomizeColors();
          });

          api.onEvent('viewport:resize', () => this.resize());
          api.onPause(() => this.stop());
          api.onResume(() => this.start());
          api.onUnmount(() => this.dispose());

          api.ready({
            capabilities: ['hot-reload'],
            subscribedEvents: ['viewport:resize']
          });
        }
      }

      randomizeColors() {
        const baseHue = Math.random() * 360;
        const colors = {
          color1: this.hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: this.hslToHex((baseHue + 30 + Math.random() * 60) % 360, 60 + Math.random() * 40, 35 + Math.random() * 25)
        };

        if (window.MyWallpaper?.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }
        Object.assign(this.settings, colors);
        this.cacheColors();
        this.settingsDirty = true;
      }

      hslToHex(h, s, l) {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      createShaderProgram() {
        const gl = this.gl;

        const vertexShaderSource = `#version 300 es
          precision mediump float;
          const vec2 positions[6] = vec2[6](
            vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
            vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
          );
          out vec2 uv;
          void main() {
            uv = positions[gl_VertexID];
            gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform float time;
          uniform vec2 resolution;
          uniform vec3 color1;
          uniform vec3 color2;
          uniform float speed;
          uniform float origin;
          uniform float direction;
          uniform float scale;
          uniform float brightness;
          uniform float opacity;
          uniform float detail;
          uniform float turbulence;
          uniform float fade;
          uniform float height;
          uniform sampler2D noiseTex;
          uniform sampler2D fbmTex;

          in vec2 uv;
          out vec4 fragColor;

          // Integer hash — kept for screen-space dithering only
          float hash(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
          }

          // Texture-based noise — hardware bilinear filtering
          float noise(vec2 p) {
            return texture(noiseTex, p / 256.0).r;
          }

          // Pre-baked FBM — single texture lookup replaces 8-iteration loop
          // RGBA channels = cumulative FBM at 2, 4, 6, 8 octaves
          float fbm(vec2 p, int octaves) {
            vec4 s = texture(fbmTex, p / 8.0);
            float fo = float(octaves);
            if (fo <= 2.0) return s.r;
            if (fo <= 4.0) return mix(s.r, s.g, (fo - 2.0) * 0.5);
            if (fo <= 6.0) return mix(s.g, s.b, (fo - 4.0) * 0.5);
            return mix(s.b, s.a, min((fo - 6.0) * 0.5, 1.0));
          }

          void main() {
            vec2 pos = uv;

            float aspectRatio = resolution.x / resolution.y;
            pos.x *= aspectRatio;

            // Origin: where smoke comes from (controls gradient/fade)
            float originRad = radians(origin);
            vec2 originDir = vec2(sin(originRad), cos(originRad));
            float gradientBasis = dot(pos, originDir);

            // Direction: where smoke travels toward (controls scroll)
            float dirRad = radians(direction);
            vec2 moveDir = vec2(sin(dirRad), cos(dirRad));

            // Speed controls all animation (scroll + turbulence)
            float t = time * speed;

            // Smoke coordinates with inverted scale (scale=1 -> freq 7, matching original)
            vec2 smokeCoords = (pos - moveDir * t) * (7.0 / scale);

            // Octaves from detail parameter (range 2-8)
            int octaves = 2 + int(detail * 2.0);

            // Base noise (reused for gradient and warp — avoids redundant fbm call)
            float baseNoise = fbm(smokeCoords, octaves);

            // Gradient with noise modulation
            float gradient = mix(gradientBasis * 0.3, gradientBasis * 0.7, baseNoise);

            // Independent Y warp (single noise — offset breaks correlation with baseNoise)
            float warpY = noise(smokeCoords * 1.7 + vec2(5.2, 1.3));

            // Turbulent movement with 2D warp (x and y warped independently)
            float noise2 = turbulence * fbm(smokeCoords + vec2(baseNoise, warpY) + t * 0.7, octaves) - 0.5;

            // Smoke intensity: cross-feed for organic movement (half octaves — already-distorted input)
            float smokeIntensity = fbm(vec2(noise2, baseNoise), max(octaves / 2, 2));

            // Color brightness
            vec3 smokeColor = mix(color2, color1, smokeIntensity) * brightness;

            // Alpha: fade controls gradient sharpness, height controls extension
            float smokeAlpha = smoothstep(0.0, fade, (smokeIntensity - gradient + 0.3) * height);

            // Dithering: break Mach bands with screen-space noise (±0.5/255)
            float dither = (hash(gl_FragCoord.xy + fract(time)) - 0.5) / 255.0;
            smokeColor += dither;
            smokeAlpha += dither;

            fragColor = vec4(smokeColor, smokeAlpha * opacity);
          }
        `;

        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) return;

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(this.program));
          return;
        }

        // Cleanup shaders after successful linkage
        gl.detachShader(this.program, vertexShader);
        gl.deleteShader(vertexShader);
        gl.detachShader(this.program, fragmentShader);
        gl.deleteShader(fragmentShader);

        gl.useProgram(this.program);

        this.uniforms = {
          time: gl.getUniformLocation(this.program, 'time'),
          resolution: gl.getUniformLocation(this.program, 'resolution'),
          color1: gl.getUniformLocation(this.program, 'color1'),
          color2: gl.getUniformLocation(this.program, 'color2'),
          speed: gl.getUniformLocation(this.program, 'speed'),
          origin: gl.getUniformLocation(this.program, 'origin'),
          direction: gl.getUniformLocation(this.program, 'direction'),
          scale: gl.getUniformLocation(this.program, 'scale'),
          brightness: gl.getUniformLocation(this.program, 'brightness'),
          opacity: gl.getUniformLocation(this.program, 'opacity'),
          detail: gl.getUniformLocation(this.program, 'detail'),
          turbulence: gl.getUniformLocation(this.program, 'turbulence'),
          fade: gl.getUniformLocation(this.program, 'fade'),
          height: gl.getUniformLocation(this.program, 'height'),
          noiseTex: gl.getUniformLocation(this.program, 'noiseTex'),
          fbmTex: gl.getUniformLocation(this.program, 'fbmTex')
        };

        // Bind textures permanently (unit 0 = noise, unit 1 = pre-baked FBM)
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.noiseTexture);
        gl.uniform1i(this.uniforms.noiseTex, 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.fbmTexture);
        gl.uniform1i(this.uniforms.fbmTex, 1);
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      hexToRgb(hex, out) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        if (result) {
          out[0] = parseInt(result[1], 16) / 255;
          out[1] = parseInt(result[2], 16) / 255;
          out[2] = parseInt(result[3], 16) / 255;
        } else {
          out[0] = out[1] = out[2] = 1;
        }
      }

      cacheColors() {
        this.hexToRgb(this.settings.color1, this.color1RGB);
        this.hexToRgb(this.settings.color2, this.color2RGB);
      }

      render = () => {
        if (!this.gl || !this.program) {
          this.animationId = requestAnimationFrame(this.render);
          return;
        }

        const gl = this.gl;

        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(this.uniforms.time, (performance.now() - this.startTime) / 1000);
        gl.uniform2fv(this.uniforms.resolution, this.resolutionArray);

        if (this.settingsDirty) {
          this.settingsDirty = false;
          gl.uniform3fv(this.uniforms.color1, this.color1RGB);
          gl.uniform3fv(this.uniforms.color2, this.color2RGB);
          gl.uniform1f(this.uniforms.speed, this.settings.speed);
          gl.uniform1f(this.uniforms.origin, this.settings.origin);
          gl.uniform1f(this.uniforms.direction, this.settings.direction);
          gl.uniform1f(this.uniforms.scale, this.settings.scale);
          gl.uniform1f(this.uniforms.brightness, this.settings.brightness);
          gl.uniform1f(this.uniforms.opacity, this.settings.opacity);
          gl.uniform1f(this.uniforms.detail, this.settings.detail);
          gl.uniform1f(this.uniforms.turbulence, this.settings.turbulence);
          gl.uniform1f(this.uniforms.fade, this.settings.fade);
          gl.uniform1f(this.uniforms.height, this.settings.height);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        this.animationId = requestAnimationFrame(this.render);
      }

      start() {
        if (!this.animationId) {
          this.render();
        }
      }

      stop() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      dispose() {
        this.stop();
        if (this.gl) {
          if (this.noiseTexture) {
            this.gl.deleteTexture(this.noiseTexture);
            this.noiseTexture = null;
          }
          if (this.fbmTexture) {
            this.gl.deleteTexture(this.fbmTexture);
            this.fbmTexture = null;
          }
          if (this.program) {
            this.gl.deleteProgram(this.program);
            this.program = null;
          }
        }
        this.gl = null;
        this.canvas = null;
        window.removeEventListener('resize', this.handleResize);
      }
    }

    if (document.readyState === 'complete') {
      window.smokeShader = new SmokeShaderAddon();
    } else {
      window.addEventListener('load', () => {
        window.smokeShader = new SmokeShaderAddon();
      });
    }
  </script>
</body>
</html>
