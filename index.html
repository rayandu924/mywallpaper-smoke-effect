<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>
  <script>
    class SmokeShaderAddon {
      constructor() {
        this.canvas = document.getElementById('smokeCanvas');
        this.gl = null;
        this.program = null;
        this.startTime = Date.now();
        this.isFirstRender = true;
        this.animationId = null;

        const config = window.MyWallpaper?.config || {};

        this.settings = {
          color1: config.color1 ?? '#6e0061',
          color2: config.color2 ?? '#ad00a1',
          speed: config.speed ?? 0.01,
          windAngle: config.windAngle ?? 0,
          scale: config.scale ?? 2.2,
          density: config.density ?? 1.35,
          softness: config.softness ?? 2.7,
          detail: config.detail ?? 2.0,
          warp: config.warp ?? 2.0,
          coverage: config.coverage ?? 1.0,
          sourceAngle: config.sourceAngle ?? 0,
          reach: config.reach ?? 0.8
        };

        // Bind methods for event listener cleanup
        this.handleResize = this.resize.bind(this);

        this.init();
      }

      init() {
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          requestAnimationFrame(() => this.init());
          return;
        }

        this.setupWebGL();
        this.createShaderProgram();
        this.setupEventListeners();
        this.render();
      }

      setupWebGL() {
        this.gl = this.canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: true
        });

        if (!this.gl) {
          this.gl = this.canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false,
            antialias: true
          });
        }

        if (!this.gl) {
          console.error('WebGL not supported');
          return;
        }

        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        this.resize();
      }

      resize() {
        const dpr = window.devicePixelRatio || 1;
        const width = this.canvas.clientWidth * dpr;
        const height = this.canvas.clientHeight * dpr;

        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          if (this.gl) {
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          }
        }
      }

      setupEventListeners() {
        window.addEventListener('resize', this.handleResize);

        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          api.onSettingsChange((newSettings) => {
            Object.assign(this.settings, newSettings);
          });

          api.onButtonClick('randomizeColorsBtn', () => {
            this.randomizeColors();
          });

          api.onEvent('viewport:resize', () => this.resize());
          api.onPause(() => this.stop());
          api.onResume(() => this.start());
          api.onUnmount(() => this.dispose());

          api.ready({
            capabilities: ['hot-reload'],
            subscribedEvents: ['viewport:resize']
          });
        }
      }

      randomizeColors() {
        const baseHue = Math.random() * 360;
        const colors = {
          color1: this.hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: this.hslToHex((baseHue + 30 + Math.random() * 60) % 360, 60 + Math.random() * 40, 35 + Math.random() * 25)
        };

        if (window.MyWallpaper?.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }
        Object.assign(this.settings, colors);
      }

      hslToHex(h, s, l) {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      createShaderProgram() {
        const gl = this.gl;

        const vertexShaderSource = `#version 300 es
          precision mediump float;
          const vec2 positions[6] = vec2[6](
            vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
            vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
          );
          out vec2 uv;
          void main() {
            uv = positions[gl_VertexID];
            gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform float time;
          uniform vec2 resolution;
          uniform vec3 color1;
          uniform vec3 color2;
          uniform float speed;
          uniform float windAngle;
          uniform float scale;
          uniform float density;
          uniform float softness;
          uniform float detail;
          uniform float warp;
          uniform float coverage;
          uniform float sourceAngle;
          uniform float reach;

          in vec2 uv;
          out vec4 fragColor;

          // Hash function for noise
          float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
          }

          // Smooth noise
          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f * f * (3.0 - 2.0 * f);

            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));

            return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
          }

          // FBM with variable octaves
          float fbm(vec2 p, int octaves) {
            float value = 0.0;
            float amplitude = 0.4;
            vec2 freq = p;

            for (int i = 0; i < 6; i++) {
              if (i >= octaves) break;
              value += amplitude * noise(freq);
              freq *= 2.0;
              amplitude *= 0.4;
            }
            return value;
          }

          void main() {
            vec2 pos = uv;
            float nx = (uv.x + 1.0) * 0.5;
            float ny = (uv.y + 1.0) * 0.5;

            // Aspect ratio correction
            float aspectRatio = resolution.x / resolution.y;
            pos.x *= aspectRatio;

            // === WIND DIRECTION ===
            float windRad = radians(windAngle);
            vec2 windDir = vec2(sin(windRad), cos(windRad));

            // Smoke coordinates - wind applied BEFORE scale
            vec2 smokeCoords = (pos - windDir * time * speed * 0.5) * scale;

            // === SOURCE DISTANCE ===
            float srcRad = radians(sourceAngle);
            vec2 srcDir = vec2(-sin(srcRad), -cos(srcRad));

            float dist = 0.0;
            if (srcDir.y < 0.0) {
              dist += abs(srcDir.y) * ny;
            } else {
              dist += abs(srcDir.y) * (1.0 - ny);
            }
            if (srcDir.x < 0.0) {
              dist += abs(srcDir.x) * nx;
            } else {
              dist += abs(srcDir.x) * (1.0 - nx);
            }

            // Normalized distance (0 at source, 1 at reach)
            float normalizedDist = clamp(dist / reach, 0.0, 1.0);

            // Smooth fade that starts early and reaches 0 at the limit
            // Fade starts at 50% of reach, fully gone at 100%
            float reachFade = 1.0 - smoothstep(0.4, 1.0, normalizedDist);

            // Natural gradient for organic dissipation
            float gradient = normalizedDist * (0.5 + fbm(smokeCoords, 3) * 0.4);

            // === MULTI-LAYER NOISE SYSTEM ===
            int octaves = 2 + int(detail * 4.0);

            // Layer 1: Base smoke shape
            float noise1 = fbm(smokeCoords, octaves);

            // Layer 2: Turbulent movement (feeds from layer 1)
            float noise2 = warp * fbm(smokeCoords + noise1 + time * 0.5, octaves) - 0.5;

            // Layer 3: Cross-feed for organic movement
            float finalNoise = warp * fbm(vec2(noise1, noise2), 3);

            // Smoke intensity: layers feeding into each other
            float smokeIntensity = fbm(vec2(noise2, noise1), octaves);

            // === COVERAGE + NATURAL DISSIPATION ===
            float smokeValue = smokeIntensity - gradient + coverage;

            // === SOFTNESS (edge width) ===
            // softness 0 = sharp edges, softness 1 = very soft/blurry edges
            float edgeSharpness = 0.1 + softness * 0.5;
            float smokeAlpha = smoothstep(0.0, edgeSharpness, smokeValue * reach);

            // === COLORS ===
            vec3 smokeColor = mix(color2, color1, smokeIntensity);

            // Apply reach fade for smooth disappearance
            float finalAlpha = smokeAlpha * density * reachFade;

            fragColor = vec4(smokeColor, finalAlpha);
          }
        `;

        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        if (!vertexShader || !fragmentShader) return;

        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(this.program));
          return;
        }

        gl.useProgram(this.program);

        this.uniforms = {
          time: gl.getUniformLocation(this.program, 'time'),
          resolution: gl.getUniformLocation(this.program, 'resolution'),
          color1: gl.getUniformLocation(this.program, 'color1'),
          color2: gl.getUniformLocation(this.program, 'color2'),
          speed: gl.getUniformLocation(this.program, 'speed'),
          windAngle: gl.getUniformLocation(this.program, 'windAngle'),
          scale: gl.getUniformLocation(this.program, 'scale'),
          density: gl.getUniformLocation(this.program, 'density'),
          softness: gl.getUniformLocation(this.program, 'softness'),
          detail: gl.getUniformLocation(this.program, 'detail'),
          warp: gl.getUniformLocation(this.program, 'warp'),
          coverage: gl.getUniformLocation(this.program, 'coverage'),
          sourceAngle: gl.getUniformLocation(this.program, 'sourceAngle'),
          reach: gl.getUniformLocation(this.program, 'reach')
        };
      }

      compileShader(source, type) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
          this.gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [1, 1, 1];
      }

      render = () => {
        if (!this.gl || !this.program) {
          this.animationId = requestAnimationFrame(this.render);
          return;
        }

        const gl = this.gl;
        const currentTime = (Date.now() - this.startTime) / 1000;

        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(this.uniforms.time, currentTime);
        gl.uniform2fv(this.uniforms.resolution, [this.canvas.width, this.canvas.height]);

        gl.uniform3fv(this.uniforms.color1, this.hexToRgb(this.settings.color1));
        gl.uniform3fv(this.uniforms.color2, this.hexToRgb(this.settings.color2));

        gl.uniform1f(this.uniforms.speed, this.settings.speed);
        gl.uniform1f(this.uniforms.windAngle, this.settings.windAngle);
        gl.uniform1f(this.uniforms.scale, this.settings.scale);
        gl.uniform1f(this.uniforms.density, this.settings.density);
        gl.uniform1f(this.uniforms.softness, this.settings.softness);
        gl.uniform1f(this.uniforms.detail, this.settings.detail);
        gl.uniform1f(this.uniforms.warp, this.settings.warp);
        gl.uniform1f(this.uniforms.coverage, this.settings.coverage);
        gl.uniform1f(this.uniforms.sourceAngle, this.settings.sourceAngle);
        gl.uniform1f(this.uniforms.reach, this.settings.reach);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this.isFirstRender && window.MyWallpaper) {
          this.isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        this.animationId = requestAnimationFrame(this.render);
      }

      start() {
        if (!this.animationId) {
          this.render();
        }
      }

      stop() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      }

      dispose() {
        this.stop();
        if (this.gl && this.program) {
          this.gl.deleteProgram(this.program);
          this.program = null;
        }
        window.removeEventListener('resize', this.handleResize);
      }
    }

    if (document.readyState === 'complete') {
      window.smokeShader = new SmokeShaderAddon();
    } else {
      window.addEventListener('load', () => {
        window.smokeShader = new SmokeShaderAddon();
      });
    }
  </script>
</body>
</html>
