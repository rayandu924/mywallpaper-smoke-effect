<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>

  <script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 u_resolution;
    uniform float u_time;
    uniform float u_speed;
    uniform float u_turbulence;
    uniform float u_density;
    uniform float u_intensity;
    uniform int u_octaves;
    uniform int u_fadeEdge;
    uniform int u_direction;
    uniform vec3 u_color1;
    uniform vec3 u_color2;
    uniform vec3 u_color3;
    uniform vec3 u_color4;

    // Improved random function with better distribution
    float hash(vec2 p) {
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    // Smooth noise with quintic interpolation for silkier results
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);

      // Quintic interpolation for smoother gradients
      vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));

      return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
    }

    // Enhanced FBM with configurable octaves and domain warping
    float fbm(vec2 p, int octaves) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;
      float lacunarity = 2.0;
      float persistence = 0.5;

      // Domain rotation matrix for less axial artifacts
      mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);

      for (int i = 0; i < 8; i++) {
        if (i >= octaves) break;
        value += amplitude * noise(p * frequency);
        p = rot * p;
        frequency *= lacunarity;
        amplitude *= persistence;
      }

      return value;
    }

    // Wispy smoke trails using ridged noise
    float ridgedNoise(vec2 p, int octaves) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;
      float prev = 1.0;

      mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);

      for (int i = 0; i < 8; i++) {
        if (i >= octaves) break;
        float n = abs(noise(p * frequency) * 2.0 - 1.0);
        n = 1.0 - n;
        n = n * n;
        value += n * amplitude * prev;
        prev = n;
        p = rot * p;
        frequency *= 2.0;
        amplitude *= 0.5;
      }

      return value;
    }

    // Turbulent noise for chaotic swirls
    float turbulentNoise(vec2 p, int octaves, float turb) {
      float value = 0.0;
      float amplitude = 0.5;
      float frequency = 1.0;

      for (int i = 0; i < 8; i++) {
        if (i >= octaves) break;
        value += amplitude * abs(noise(p * frequency) * 2.0 - 1.0);
        frequency *= 2.0 + turb * 0.1;
        amplitude *= 0.5;
      }

      return value;
    }

    // Get movement vector based on direction
    vec2 getMovement(float time, float speed) {
      // 0: up, 1: down, 2: left, 3: right, 4: spiral
      if (u_direction == 0) return vec2(0.0, time * speed);
      if (u_direction == 1) return vec2(0.0, -time * speed);
      if (u_direction == 2) return vec2(time * speed, 0.0);
      if (u_direction == 3) return vec2(-time * speed, 0.0);
      // Spiral
      return vec2(sin(time * 0.5) * speed, cos(time * 0.5) * speed) * time * 0.3;
    }

    // Calculate fade based on edge mode
    float getFade(vec2 uv) {
      // 0: none, 1: bottom, 2: top, 3: both, 4: radial
      if (u_fadeEdge == 0) return 1.0;
      if (u_fadeEdge == 1) return smoothstep(0.0, 0.5, uv.y);
      if (u_fadeEdge == 2) return smoothstep(1.0, 0.5, uv.y);
      if (u_fadeEdge == 3) return smoothstep(0.0, 0.3, uv.y) * smoothstep(1.0, 0.7, uv.y);
      // Radial vignette
      vec2 center = uv - 0.5;
      float dist = length(center);
      return 1.0 - smoothstep(0.3, 0.8, dist);
    }

    void main() {
      vec2 uv = gl_FragCoord.xy / u_resolution.xy;
      vec2 p = gl_FragCoord.xy * u_density / u_resolution.x;

      float time = u_time * u_speed;
      vec2 movement = getMovement(time, 0.7);

      // Multi-layer domain warping for complex smoke behavior
      float warp1 = fbm(p + movement * 0.5, u_octaves);
      float warp2 = fbm(p - movement * 0.3 + warp1 * u_turbulence * 0.5, u_octaves);

      // Create multiple noise layers
      vec2 warpedP = p + vec2(warp1, warp2) * u_turbulence * 0.3;

      float smoke1 = fbm(warpedP + time * 0.1, u_octaves);
      float smoke2 = ridgedNoise(warpedP * 0.8 - time * 0.15, u_octaves);
      float smoke3 = turbulentNoise(warpedP * 1.2 + time * 0.08, u_octaves, u_turbulence);

      // Secondary warp layer for depth
      vec2 r = vec2(
        fbm(p + smoke1 + time * 0.4 - p.x * 0.3, u_octaves),
        fbm(p + smoke1 - time * 0.25 + p.y * 0.2, u_octaves)
      );

      // Blend colors based on noise values
      vec3 col1 = mix(u_color1, u_color2, fbm(p + r * 2.0, u_octaves));
      vec3 col2 = mix(u_color3, u_color4, r.x * 1.5);

      // Combine with wispy details
      vec3 color = col1 + col2 * smoke2;

      // Add ethereal glow from color4
      float glow = smoke3 * 0.5;
      color += u_color4 * glow * 0.8;

      // Subtle color shift based on position
      float shift = cos(1.6 * gl_FragCoord.y / u_resolution.y + time * 0.2);
      color *= shift * 0.3 + 0.7;

      // Apply intensity
      color *= u_intensity;

      // Apply edge fade
      float fade = getFade(uv);
      color *= fade;

      // Subtle film grain for organic feel
      float grain = hash(uv + fract(time)) * 0.03;
      color += grain;

      // Ensure we don't exceed bounds while maintaining vibrancy
      color = clamp(color, 0.0, 1.0);

      gl_FragColor = vec4(color, 1.0);
    }
  </script>

  <script>
    (function() {
      'use strict';

      // State
      let gl, program, canvas;
      let animationId = null;
      let startTime = Date.now();
      let config = {};
      let uniforms = {};
      let isReady = false;

      // Default config
      const defaults = {
        color1: '#6e0061',
        color2: '#ad00a1',
        color3: '#a401d6',
        color4: '#4a0080',
        speed: 0.8,
        turbulence: 4,
        density: 8,
        intensity: 1,
        fadeEdge: 'bottom',
        direction: 'up',
        octaves: 6
      };

      // Convert hex to RGB (0-1 range)
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16) / 255,
          g: parseInt(result[2], 16) / 255,
          b: parseInt(result[3], 16) / 255
        } : { r: 0, g: 0, b: 0 };
      }

      // Map string values to integers for shader
      function fadeEdgeToInt(value) {
        const map = { none: 0, bottom: 1, top: 2, both: 3, radial: 4 };
        return map[value] || 1;
      }

      function directionToInt(value) {
        const map = { up: 0, down: 1, left: 2, right: 3, spiral: 4 };
        return map[value] || 0;
      }

      // Initialize WebGL
      function initWebGL() {
        canvas = document.getElementById('smokeCanvas');
        gl = canvas.getContext('webgl', {
          antialias: true,
          preserveDrawingBuffer: false,
          powerPreference: 'high-performance'
        });

        if (!gl) {
          console.error('WebGL not supported');
          return false;
        }

        // Create shaders
        const vertexShader = createShader(gl.VERTEX_SHADER,
          document.getElementById('vertexShader').textContent);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER,
          document.getElementById('fragmentShader').textContent);

        if (!vertexShader || !fragmentShader) return false;

        // Create program
        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(program));
          return false;
        }

        gl.useProgram(program);

        // Setup geometry (fullscreen quad)
        const positions = new Float32Array([
          -1, -1,
           1, -1,
          -1,  1,
          -1,  1,
           1, -1,
           1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Cache uniform locations
        uniforms = {
          resolution: gl.getUniformLocation(program, 'u_resolution'),
          time: gl.getUniformLocation(program, 'u_time'),
          speed: gl.getUniformLocation(program, 'u_speed'),
          turbulence: gl.getUniformLocation(program, 'u_turbulence'),
          density: gl.getUniformLocation(program, 'u_density'),
          intensity: gl.getUniformLocation(program, 'u_intensity'),
          octaves: gl.getUniformLocation(program, 'u_octaves'),
          fadeEdge: gl.getUniformLocation(program, 'u_fadeEdge'),
          direction: gl.getUniformLocation(program, 'u_direction'),
          color1: gl.getUniformLocation(program, 'u_color1'),
          color2: gl.getUniformLocation(program, 'u_color2'),
          color3: gl.getUniformLocation(program, 'u_color3'),
          color4: gl.getUniformLocation(program, 'u_color4')
        };

        return true;
      }

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const width = window.innerWidth;
        const height = window.innerHeight;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        if (gl) {
          gl.viewport(0, 0, canvas.width, canvas.height);
        }
      }

      function updateUniforms() {
        if (!gl || !program) return;

        const c1 = hexToRgb(config.color1 || defaults.color1);
        const c2 = hexToRgb(config.color2 || defaults.color2);
        const c3 = hexToRgb(config.color3 || defaults.color3);
        const c4 = hexToRgb(config.color4 || defaults.color4);

        gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
        gl.uniform1f(uniforms.speed, config.speed ?? defaults.speed);
        gl.uniform1f(uniforms.turbulence, config.turbulence ?? defaults.turbulence);
        gl.uniform1f(uniforms.density, config.density ?? defaults.density);
        gl.uniform1f(uniforms.intensity, config.intensity ?? defaults.intensity);
        gl.uniform1i(uniforms.octaves, config.octaves ?? defaults.octaves);
        gl.uniform1i(uniforms.fadeEdge, fadeEdgeToInt(config.fadeEdge ?? defaults.fadeEdge));
        gl.uniform1i(uniforms.direction, directionToInt(config.direction ?? defaults.direction));
        gl.uniform3f(uniforms.color1, c1.r, c1.g, c1.b);
        gl.uniform3f(uniforms.color2, c2.r, c2.g, c2.b);
        gl.uniform3f(uniforms.color3, c3.r, c3.g, c3.b);
        gl.uniform3f(uniforms.color4, c4.r, c4.g, c4.b);
      }

      function render() {
        if (!gl || !program) return;

        const time = (Date.now() - startTime) / 1000;
        gl.uniform1f(uniforms.time, time);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        animationId = requestAnimationFrame(render);
      }

      function start() {
        if (animationId) return;
        resize();
        updateUniforms();
        render();
      }

      function stop() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
      }

      function applyConfig(newConfig) {
        config = { ...config, ...newConfig };
        updateUniforms();
      }

      // Generate random harmonious colors using HSL
      function randomizeColors() {
        // Pick a random base hue
        const baseHue = Math.random() * 360;

        // Generate 4 colors with harmonic relationships
        const colors = {
          color1: hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: hslToHex((baseHue + 30 + Math.random() * 30) % 360, 70 + Math.random() * 30, 30 + Math.random() * 20),
          color3: hslToHex((baseHue + 60 + Math.random() * 60) % 360, 60 + Math.random() * 40, 40 + Math.random() * 20),
          color4: hslToHex((baseHue + 180 + Math.random() * 60 - 30) % 360, 50 + Math.random() * 50, 25 + Math.random() * 15)
        };

        // Update config and notify MyWallpaper to update UI
        if (window.MyWallpaper && window.MyWallpaper.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }

        applyConfig(colors);
      }

      // Convert HSL to Hex
      function hslToHex(h, s, l) {
        s /= 100;
        l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      // Initialize
      function init() {
        if (!initWebGL()) {
          console.error('Failed to initialize WebGL');
          return;
        }

        resize();

        // Handle resize
        window.addEventListener('resize', () => {
          resize();
          updateUniforms();
        });

        // Check for MyWallpaper API
        if (window.MyWallpaper) {
          const api = window.MyWallpaper;

          // Get initial config
          config = { ...defaults, ...api.config };

          // Handle settings changes (hot-reload)
          api.onSettingsChange((newConfig) => {
            applyConfig(newConfig);
          });

          // Handle randomize colors button
          api.onButtonClick('randomizeColorsBtn', () => {
            randomizeColors();
          });

          // Handle viewport resize
          api.onEvent('viewport:resize', (data) => {
            resize();
            updateUniforms();
          });

          // Lifecycle events
          api.onPause(() => {
            stop();
          });

          api.onResume(() => {
            start();
          });

          // Signal ready
          api.ready({
            supportsHotReload: true
          });

          isReady = true;
        } else {
          // Standalone mode (for testing)
          config = { ...defaults };
          isReady = true;
        }

        // Start animation
        start();
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
