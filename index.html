<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smoke Effect</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="smokeCanvas"></canvas>

  <script>
    (function() {
      'use strict';

      // State
      let gl, program, canvas;
      let animationId = null;
      let startTime = Date.now();
      let config = {};
      let uniforms = {};
      let isFirstRender = true;

      // Default config
      const defaults = {
        color1: '#6e0061',
        color2: '#ad00a1',
        color3: '#a401d6',
        color4: '#4a0080',
        speed: 0.8,
        turbulence: 4,
        density: 8,
        intensity: 1,
        fadeEdge: 'bottom',
        direction: 'up',
        octaves: 6
      };

      // Vertex Shader (WebGL2)
      const vertexShaderSource = `#version 300 es
        precision mediump float;
        const vec2 positions[6] = vec2[6](
          vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
          vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
        );
        out vec2 vUv;
        void main() {
          vUv = positions[gl_VertexID] * 0.5 + 0.5;
          gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);
        }
      `;

      // Fragment Shader (WebGL2) - Enhanced smoke effect
      const fragmentShaderSource = `#version 300 es
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_speed;
        uniform float u_turbulence;
        uniform float u_density;
        uniform float u_intensity;
        uniform int u_octaves;
        uniform int u_fadeEdge;
        uniform int u_direction;
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform vec3 u_color3;
        uniform vec3 u_color4;

        in vec2 vUv;
        out vec4 fragColor;

        // High quality random
        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        // Smooth noise with cubic interpolation
        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));

          // Smooth interpolation
          vec2 u = f * f * (3.0 - 2.0 * f);

          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        // FBM with configurable octaves
        float fbm(vec2 st, int octaves) {
          float value = 0.0;
          float amplitude = 0.5;
          vec2 freq = st;

          for (int i = 0; i < 8; i++) {
            if (i >= octaves) break;
            value += amplitude * noise(freq);
            freq *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        // Turbulent FBM for wispy effect
        float turbulentFbm(vec2 st, int octaves) {
          float value = 0.0;
          float amplitude = 0.5;
          vec2 freq = st;

          for (int i = 0; i < 8; i++) {
            if (i >= octaves) break;
            value += amplitude * abs(noise(freq) * 2.0 - 1.0);
            freq *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        // Get movement based on direction
        vec2 getMovement(float time) {
          float sp = u_speed * 0.15;
          if (u_direction == 0) return vec2(0.0, time * sp);      // up
          if (u_direction == 1) return vec2(0.0, -time * sp);     // down
          if (u_direction == 2) return vec2(time * sp, 0.0);      // left
          if (u_direction == 3) return vec2(-time * sp, 0.0);     // right
          // spiral
          return vec2(sin(time * 0.3), cos(time * 0.3)) * time * sp * 0.5;
        }

        // Calculate fade based on edge mode
        float getFade(vec2 uv) {
          if (u_fadeEdge == 0) return 1.0;  // none
          if (u_fadeEdge == 1) return smoothstep(0.0, 0.6, uv.y);  // bottom
          if (u_fadeEdge == 2) return smoothstep(1.0, 0.4, uv.y);  // top
          if (u_fadeEdge == 3) return smoothstep(0.0, 0.35, uv.y) * smoothstep(1.0, 0.65, uv.y);  // both
          // radial vignette
          vec2 center = uv - 0.5;
          float dist = length(center);
          return 1.0 - smoothstep(0.2, 0.7, dist);
        }

        void main() {
          vec2 uv = vUv;
          float time = u_time;

          // Aspect ratio correction
          float aspectRatio = u_resolution.x / u_resolution.y;
          vec2 st = vec2(uv.x * aspectRatio, uv.y);

          // Movement
          vec2 movement = getMovement(time);

          // Scale coordinates
          vec2 smokeCoords = st * u_density + movement;

          // First noise layer - base smoke shape
          float noise1 = fbm(smokeCoords, u_octaves);

          // Second noise layer with turbulence - adds detail
          float turb = u_turbulence * 0.1;
          float noise2 = turb * fbm(smokeCoords + noise1 * 2.0 + time * 0.1, u_octaves) - 0.3;

          // Combine noises for final smoke pattern (like fire shader technique)
          float smokePattern = fbm(vec2(noise1, noise2) * 3.0, u_octaves);
          float smokeDetail = fbm(vec2(noise2, noise1) * 2.0, u_octaves);

          // Wispy trails
          float wisps = turbulentFbm(smokeCoords * 0.8 - movement * 0.5, u_octaves) * 0.5;

          // Color mixing based on noise values
          vec3 col1 = mix(u_color1, u_color2, smokePattern);
          vec3 col2 = mix(u_color3, u_color4, smokeDetail);

          // Final color blend
          vec3 smokeColor = mix(col1, col2, wisps + 0.3);

          // Add glow from color4
          smokeColor += u_color4 * smokeDetail * 0.4;

          // Apply intensity
          smokeColor *= u_intensity;

          // Calculate alpha for transparency effect
          float smokeAlpha = smoothstep(0.1, 0.9, smokePattern + smokeDetail * 0.5);
          smokeAlpha *= smoothstep(0.0, 0.3, wisps + 0.4);

          // Apply edge fade
          float fade = getFade(uv);
          smokeAlpha *= fade;

          // Ensure color doesn't exceed bounds
          smokeColor = clamp(smokeColor, 0.0, 1.0);

          fragColor = vec4(smokeColor, smokeAlpha);
        }
      `;

      // Fallback shaders for WebGL1
      const vertexShaderSourceV1 = `
        attribute vec2 a_position;
        varying vec2 vUv;
        void main() {
          vUv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentShaderSourceV1 = `
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_speed;
        uniform float u_turbulence;
        uniform float u_density;
        uniform float u_intensity;
        uniform int u_octaves;
        uniform int u_fadeEdge;
        uniform int u_direction;
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform vec3 u_color3;
        uniform vec3 u_color4;

        varying vec2 vUv;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < 6; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        float turbulentFbm(vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < 6; i++) {
            value += amplitude * abs(noise(st) * 2.0 - 1.0);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        vec2 getMovement(float time) {
          float sp = u_speed * 0.15;
          if (u_direction == 0) return vec2(0.0, time * sp);
          if (u_direction == 1) return vec2(0.0, -time * sp);
          if (u_direction == 2) return vec2(time * sp, 0.0);
          if (u_direction == 3) return vec2(-time * sp, 0.0);
          return vec2(sin(time * 0.3), cos(time * 0.3)) * time * sp * 0.5;
        }

        float getFade(vec2 uv) {
          if (u_fadeEdge == 0) return 1.0;
          if (u_fadeEdge == 1) return smoothstep(0.0, 0.6, uv.y);
          if (u_fadeEdge == 2) return smoothstep(1.0, 0.4, uv.y);
          if (u_fadeEdge == 3) return smoothstep(0.0, 0.35, uv.y) * smoothstep(1.0, 0.65, uv.y);
          vec2 center = uv - 0.5;
          return 1.0 - smoothstep(0.2, 0.7, length(center));
        }

        void main() {
          vec2 uv = vUv;
          float time = u_time;
          float aspectRatio = u_resolution.x / u_resolution.y;
          vec2 st = vec2(uv.x * aspectRatio, uv.y);
          vec2 movement = getMovement(time);
          vec2 smokeCoords = st * u_density + movement;

          float noise1 = fbm(smokeCoords);
          float turb = u_turbulence * 0.1;
          float noise2 = turb * fbm(smokeCoords + noise1 * 2.0 + time * 0.1) - 0.3;
          float smokePattern = fbm(vec2(noise1, noise2) * 3.0);
          float smokeDetail = fbm(vec2(noise2, noise1) * 2.0);
          float wisps = turbulentFbm(smokeCoords * 0.8 - movement * 0.5) * 0.5;

          vec3 col1 = mix(u_color1, u_color2, smokePattern);
          vec3 col2 = mix(u_color3, u_color4, smokeDetail);
          vec3 smokeColor = mix(col1, col2, wisps + 0.3);
          smokeColor += u_color4 * smokeDetail * 0.4;
          smokeColor *= u_intensity;

          float smokeAlpha = smoothstep(0.1, 0.9, smokePattern + smokeDetail * 0.5);
          smokeAlpha *= smoothstep(0.0, 0.3, wisps + 0.4);
          smokeAlpha *= getFade(uv);

          smokeColor = clamp(smokeColor, 0.0, 1.0);
          gl_FragColor = vec4(smokeColor, smokeAlpha);
        }
      `;

      // Convert hex to RGB (0-1 range)
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [0, 0, 0];
      }

      // Map string values to integers for shader
      function fadeEdgeToInt(value) {
        const map = { none: 0, bottom: 1, top: 2, both: 3, radial: 4 };
        return value in map ? map[value] : 1;
      }

      function directionToInt(value) {
        const map = { up: 0, down: 1, left: 2, right: 3, spiral: 4 };
        return value in map ? map[value] : 0;
      }

      // Initialize WebGL (try WebGL2 first, fallback to WebGL1)
      let isWebGL2 = false;

      function initWebGL() {
        canvas = document.getElementById('smokeCanvas');

        // Try WebGL2 first
        gl = canvas.getContext('webgl2', {
          alpha: true,
          premultipliedAlpha: false,
          antialias: true,
          powerPreference: 'high-performance'
        });

        if (gl) {
          isWebGL2 = true;
          console.log('ðŸŒ«ï¸ Smoke Effect: Using WebGL2');
        } else {
          // Fallback to WebGL1
          gl = canvas.getContext('webgl', {
            alpha: true,
            premultipliedAlpha: false,
            antialias: true
          });
          console.log('ðŸŒ«ï¸ Smoke Effect: Using WebGL1 fallback');
        }

        if (!gl) {
          console.error('WebGL not supported');
          return false;
        }

        // Enable blending for transparency
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);

        // Create shaders based on WebGL version
        const vertSrc = isWebGL2 ? vertexShaderSource : vertexShaderSourceV1;
        const fragSrc = isWebGL2 ? fragmentShaderSource : fragmentShaderSourceV1;

        const vertexShader = createShader(gl.VERTEX_SHADER, vertSrc);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragSrc);

        if (!vertexShader || !fragmentShader) return false;

        // Create program
        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(program));
          return false;
        }

        gl.useProgram(program);

        // Setup geometry for WebGL1 (WebGL2 uses gl_VertexID)
        if (!isWebGL2) {
          const positions = new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
          ]);
          const buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

          const positionLoc = gl.getAttribLocation(program, 'a_position');
          gl.enableVertexAttribArray(positionLoc);
          gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Cache uniform locations
        uniforms = {
          resolution: gl.getUniformLocation(program, 'u_resolution'),
          time: gl.getUniformLocation(program, 'u_time'),
          speed: gl.getUniformLocation(program, 'u_speed'),
          turbulence: gl.getUniformLocation(program, 'u_turbulence'),
          density: gl.getUniformLocation(program, 'u_density'),
          intensity: gl.getUniformLocation(program, 'u_intensity'),
          octaves: gl.getUniformLocation(program, 'u_octaves'),
          fadeEdge: gl.getUniformLocation(program, 'u_fadeEdge'),
          direction: gl.getUniformLocation(program, 'u_direction'),
          color1: gl.getUniformLocation(program, 'u_color1'),
          color2: gl.getUniformLocation(program, 'u_color2'),
          color3: gl.getUniformLocation(program, 'u_color3'),
          color4: gl.getUniformLocation(program, 'u_color4')
        };

        return true;
      }

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;

        if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
          canvas.width = width * dpr;
          canvas.height = height * dpr;

          if (gl) {
            gl.viewport(0, 0, canvas.width, canvas.height);
          }
        }
      }

      function updateUniforms() {
        if (!gl || !program) return;

        const c1 = hexToRgb(config.color1 || defaults.color1);
        const c2 = hexToRgb(config.color2 || defaults.color2);
        const c3 = hexToRgb(config.color3 || defaults.color3);
        const c4 = hexToRgb(config.color4 || defaults.color4);

        gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
        gl.uniform1f(uniforms.speed, config.speed ?? defaults.speed);
        gl.uniform1f(uniforms.turbulence, config.turbulence ?? defaults.turbulence);
        gl.uniform1f(uniforms.density, config.density ?? defaults.density);
        gl.uniform1f(uniforms.intensity, config.intensity ?? defaults.intensity);
        gl.uniform1i(uniforms.octaves, config.octaves ?? defaults.octaves);
        gl.uniform1i(uniforms.fadeEdge, fadeEdgeToInt(config.fadeEdge ?? defaults.fadeEdge));
        gl.uniform1i(uniforms.direction, directionToInt(config.direction ?? defaults.direction));
        gl.uniform3fv(uniforms.color1, c1);
        gl.uniform3fv(uniforms.color2, c2);
        gl.uniform3fv(uniforms.color3, c3);
        gl.uniform3fv(uniforms.color4, c4);
      }

      function render() {
        if (!gl || !program) return;

        const time = (Date.now() - startTime) / 1000;
        gl.uniform1f(uniforms.time, time);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Signal ready after first render
        if (isFirstRender && window.MyWallpaper) {
          isFirstRender = false;
          window.MyWallpaper.renderComplete();
        }

        animationId = requestAnimationFrame(render);
      }

      function start() {
        if (animationId) return;
        resize();
        updateUniforms();
        render();
      }

      function stop() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
      }

      function applyConfig(newConfig) {
        config = { ...config, ...newConfig };
        updateUniforms();
      }

      // Generate random harmonious colors using HSL
      function randomizeColors() {
        const baseHue = Math.random() * 360;

        const colors = {
          color1: hslToHex(baseHue, 70 + Math.random() * 30, 20 + Math.random() * 20),
          color2: hslToHex((baseHue + 30 + Math.random() * 30) % 360, 70 + Math.random() * 30, 30 + Math.random() * 20),
          color3: hslToHex((baseHue + 60 + Math.random() * 60) % 360, 60 + Math.random() * 40, 40 + Math.random() * 20),
          color4: hslToHex((baseHue + 180 + Math.random() * 60 - 30) % 360, 50 + Math.random() * 50, 25 + Math.random() * 15)
        };

        if (window.MyWallpaper && window.MyWallpaper.settings) {
          window.MyWallpaper.settings.setValues(colors);
        }

        applyConfig(colors);
      }

      function hslToHex(h, s, l) {
        s /= 100;
        l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      }

      // Initialize
      function init() {
        if (!initWebGL()) {
          console.error('Failed to initialize WebGL');
          return;
        }

        resize();

        window.addEventListener('resize', () => {
          resize();
          updateUniforms();
        });

        // Check for MyWallpaper API
        if (window.MyWallpaper) {
          const api = window.MyWallpaper;
          config = { ...defaults, ...api.config };

          api.onSettingsChange((newConfig) => {
            applyConfig(newConfig);
          });

          api.onButtonClick('randomizeColorsBtn', () => {
            randomizeColors();
          });

          api.onEvent('viewport:resize', () => {
            resize();
            updateUniforms();
          });

          api.onPause(() => stop());
          api.onResume(() => start());

          api.ready({ supportsHotReload: true });
        } else {
          config = { ...defaults };
        }

        start();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
